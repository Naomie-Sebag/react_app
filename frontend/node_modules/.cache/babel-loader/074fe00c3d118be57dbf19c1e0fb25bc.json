{"ast":null,"code":"/*\n * node-kmeans\n * Copyright(c) 2012 Philmod <philippe.modard@gmail.com>\n * MIT Licensed\n */\n\n/*\nAsynchronous implementation of the k-means clustering algorithm.\n\nThe kmeans function takes as input the number k of clusters and a list of N\ninput vectors and it outputs an object with two attributes:\n  - centroids: an Array of k vectors containing the centroid of each cluster\n  - assignments: An Array of size N representing for each input vector the\n    index of the cluster\n\nThe kmeans will return an error if:\n  - N < k\n  - The number of different input vectors is smaller than k\n*/\nconst _ = require('underscore');\n/**\n * Compute the Euclidean distance\n *\n * @param {Array} a\n * @param {Array} b\n * @api private\n */\n\n\nfunction euclidianDistance(a, b) {\n  if (a.length !== b.length) {\n    return new Error('The vectors must have the same length');\n  }\n\n  let d = 0.0;\n\n  for (let i = 0, max = a.length; i < max; ++i) {\n    d += (a[i] - b[i]) ** 2;\n  }\n\n  return Math.sqrt(d);\n}\n\nclass Group {\n  constructor() {\n    this.centroidMoved = true;\n  }\n\n  initCluster() {\n    this.cluster = []; // dimensions\n\n    this.clusterInd = []; // index\n  }\n  /**\n   * Define Centroid\n   *  - if they exist, calculate the new position\n   *  - otherwise, randomly choose one existing item\n   */\n\n\n  defineCentroid(self) {\n    this.centroidOld = this.centroid ? this.centroid : [];\n\n    if (this.centroid && this.cluster.length > 0) {\n      this.calculateCentroid();\n    } else {\n      // random selection\n      const i = Math.floor(Math.random() * self.indexes.length);\n      this.centroidIndex = self.indexes[i];\n      self.indexes.splice(i, 1);\n      this.centroid = [];\n\n      if (!_.isArray(self.v[this.centroidIndex])) {\n        // only one dimension\n        this.centroid[0] = self.v[this.centroidIndex];\n      } else {\n        for (let j = 0, max = self.v[this.centroidIndex].length; j < max; ++j) {\n          this.centroid[j] = self.v[this.centroidIndex][j];\n        }\n      }\n    } // Centroid has moved if old value != new value\n\n\n    this.centroidMoved = !_.isEqual(this.centroid, this.centroidOld);\n    return this;\n  }\n\n  calculateCentroid() {\n    this.centroid = [];\n\n    for (let i = 0; i < this.cluster.length; ++i) {\n      // loop through the cluster elements\n      for (let j = 0, max = this.cluster[i].length; j < max; ++j) {\n        // loop through the dimensions\n        this.centroid[j] = this.centroid[j] ? this.centroid[j] + this.cluster[i][j] : this.cluster[i][j];\n      }\n    }\n\n    for (let i = 0, max = this.centroid.length; i < max; ++i) {\n      this.centroid[i] = this.centroid[i] / this.cluster.length; // average\n    }\n\n    return this;\n  }\n\n  distanceObjects(self) {\n    if (!this.distances) {\n      this.distances = [];\n    }\n\n    for (let i = 0, max = self.v.length; i < max; ++i) {\n      this.distances[i] = self.distanceFunction(this.centroid, self.v[i]);\n    }\n\n    return this;\n  }\n\n}\n\nclass Clusterize {\n  constructor(vector, options, callback) {\n    if (!callback || !options || !vector) {\n      throw new Error('Provide 3 arguments: vector, options, callback');\n    }\n\n    if (typeof callback !== 'function') {\n      throw new Error('Provide a callback function');\n    }\n\n    if (!options || !options.k || options.k < 1) {\n      return callback(new Error('Provide a correct number k of clusters'));\n    }\n\n    if (options.distance && (typeof options.distance !== 'function' || options.distance.length !== 2)) {\n      return callback(new Error('options.distance must be a function with two arguments'));\n    }\n\n    if (!_.isArray(vector)) {\n      return callback(new Error('Provide an array of data'));\n    }\n\n    this.options = options;\n    this.v = this.checkV(vector);\n    this.k = this.options.k;\n    this.distanceFunction = this.options.distance || euclidianDistance;\n\n    if (this.v.length < this.k) {\n      const errMessage = `The number of points must be greater than\n      the number k of clusters`;\n      return callback(new Error(errMessage));\n    }\n\n    this.initialize(); // initialize the group arrays\n\n    const self = this;\n    let moved = -1;\n\n    function iterate() {\n      if (moved === 0) {\n        return callback(null, self.output()); // converged if 0 centroid has moved\n      }\n\n      moved = 0;\n\n      for (let i = 0, max = self.groups.length; i < max; ++i) {\n        self.groups[i].defineCentroid(self); // define the new centroids\n\n        self.groups[i].distanceObjects(self); // distances from centroids to items\n      }\n\n      self.clustering(); // clustering by choosing the centroid the closest of each item\n\n      for (let i = 0, max = self.groups.length; i < max; ++i) {\n        // check how many centroids have moved in this iteration\n        if (self.groups[i].centroidMoved) {\n          moved++;\n        }\n      }\n\n      return process.nextTick(iterate);\n    }\n\n    return iterate();\n  }\n\n  checkV(v) {\n    let dim = 1;\n\n    if (_.isArray(v[0])) {\n      dim = v[0].length;\n    }\n\n    for (let i = 0, max = v.length; i < max; ++i) {\n      if (!_.isArray(v[i])) {\n        if (dim !== 1) {\n          throw new Error('All the elements must have the same dimension');\n        }\n\n        v[i] = Number(v[i]);\n\n        if (Number.isNaN(v[i])) {\n          throw new Error('All the elements must be float type');\n        }\n      } else {\n        if (v[i].length !== dim) {\n          throw new Error('All the elements must have the same dimension');\n        }\n\n        for (let j = 0, max2 = v[i].length; j < max2; ++j) {\n          v[i][j] = Number(v[i][j]);\n\n          if (Number.isNaN(v[i][j])) {\n            throw new Error('All the elements must be float type');\n          }\n        }\n      }\n    }\n\n    return v;\n  }\n\n  initialize() {\n    this.groups = [];\n\n    for (let i = 0, max = this.k; i < max; ++i) {\n      this.groups[i] = new Group(this);\n    }\n\n    this.indexes = []; // used to choose randomly the initial centroids\n\n    for (let i = 0, max = this.v.length; i < max; ++i) {\n      this.indexes[i] = i;\n    }\n\n    return this;\n  }\n\n  clustering() {\n    for (let j = 0, max = this.groups.length; j < max; ++j) {\n      this.groups[j].initCluster();\n    }\n\n    for (let i = 0, max = this.v.length; i < max; ++i) {\n      let min = this.groups[0].distances[i];\n      let indexGroup = 0;\n\n      for (let j = 1, max2 = this.groups.length; j < max2; ++j) {\n        if (this.groups[j].distances[i] < min) {\n          min = this.groups[j].distances[i];\n          indexGroup = j;\n        }\n      }\n\n      this.groups[indexGroup].cluster.push(this.v[i]);\n      this.groups[indexGroup].clusterInd.push(i);\n    }\n\n    return this;\n  }\n\n  output() {\n    const out = [];\n\n    for (let j = 0, max = this.groups.length; j < max; ++j) {\n      out[j] = _.pick(this.groups[j], 'centroid', 'cluster', 'clusterInd');\n    }\n\n    return out;\n  }\n\n}\n\nexports.clusterize = (vector, options, callback) => {\n  return new Clusterize(vector, options, callback);\n};\n\nexports._class = Clusterize;","map":{"version":3,"sources":["D:/Users/naomi/Downloads/web_react_project/frontend/node_modules/node-kmeans/lib/kmeans.js"],"names":["_","require","euclidianDistance","a","b","length","Error","d","i","max","Math","sqrt","Group","constructor","centroidMoved","initCluster","cluster","clusterInd","defineCentroid","self","centroidOld","centroid","calculateCentroid","floor","random","indexes","centroidIndex","splice","isArray","v","j","isEqual","distanceObjects","distances","distanceFunction","Clusterize","vector","options","callback","k","distance","checkV","errMessage","initialize","moved","iterate","output","groups","clustering","process","nextTick","dim","Number","isNaN","max2","min","indexGroup","push","out","pick","exports","clusterize","_class"],"mappings":"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","sourcesContent":["/*\n * node-kmeans\n * Copyright(c) 2012 Philmod <philippe.modard@gmail.com>\n * MIT Licensed\n */\n\n/*\nAsynchronous implementation of the k-means clustering algorithm.\n\nThe kmeans function takes as input the number k of clusters and a list of N\ninput vectors and it outputs an object with two attributes:\n  - centroids: an Array of k vectors containing the centroid of each cluster\n  - assignments: An Array of size N representing for each input vector the\n    index of the cluster\n\nThe kmeans will return an error if:\n  - N < k\n  - The number of different input vectors is smaller than k\n*/\n\nconst _ = require('underscore');\n\n\n/**\n * Compute the Euclidean distance\n *\n * @param {Array} a\n * @param {Array} b\n * @api private\n */\n\nfunction euclidianDistance(a, b) {\n  if (a.length !== b.length) {\n    return (new Error('The vectors must have the same length'));\n  }\n  let d = 0.0;\n  for (let i = 0, max = a.length; i < max; ++i) {\n    d += (a[i] - b[i]) ** 2;\n  }\n  return Math.sqrt(d);\n}\n\nclass Group {\n  constructor() {\n    this.centroidMoved = true;\n  }\n\n  initCluster() {\n    this.cluster = []; // dimensions\n    this.clusterInd = []; // index\n  }\n\n  /**\n   * Define Centroid\n   *  - if they exist, calculate the new position\n   *  - otherwise, randomly choose one existing item\n   */\n  defineCentroid(self) {\n    this.centroidOld = (this.centroid) ? this.centroid : [];\n    if (this.centroid && this.cluster.length > 0) {\n      this.calculateCentroid();\n    } else { // random selection\n      const i = Math.floor(Math.random() * self.indexes.length);\n      this.centroidIndex = self.indexes[i];\n      self.indexes.splice(i, 1);\n      this.centroid = [];\n      if (!_.isArray(self.v[this.centroidIndex])) { // only one dimension\n        this.centroid[0] = self.v[this.centroidIndex];\n      } else {\n        for (let j = 0, max = self.v[this.centroidIndex].length; j < max; ++j) {\n          this.centroid[j] = self.v[this.centroidIndex][j];\n        }\n      }\n    }\n    // Centroid has moved if old value != new value\n    this.centroidMoved = !_.isEqual(this.centroid, this.centroidOld);\n    return this;\n  }\n\n  calculateCentroid() {\n    this.centroid = [];\n    for (let i = 0; i < this.cluster.length; ++i) { // loop through the cluster elements\n      for (let j = 0, max = this.cluster[i].length; j < max; ++j) { // loop through the dimensions\n        this.centroid[j] = this.centroid[j]\n          ? this.centroid[j] + this.cluster[i][j]\n          : this.cluster[i][j];\n      }\n    }\n    for (let i = 0, max = this.centroid.length; i < max; ++i) {\n      this.centroid[i] = this.centroid[i] / this.cluster.length; // average\n    }\n    return this;\n  }\n\n  distanceObjects(self) {\n    if (!this.distances) {\n      this.distances = [];\n    }\n    for (let i = 0, max = self.v.length; i < max; ++i) {\n      this.distances[i] = self.distanceFunction(this.centroid, self.v[i]);\n    }\n    return this;\n  }\n}\n\n\nclass Clusterize {\n  constructor(vector, options, callback) {\n    if (!callback || !options || !vector) {\n      throw new Error('Provide 3 arguments: vector, options, callback');\n    }\n    if (typeof callback !== 'function') {\n      throw new Error('Provide a callback function');\n    }\n    if (!options || !options.k || options.k < 1) {\n      return callback(new Error('Provide a correct number k of clusters'));\n    }\n    if (options.distance\n       && (typeof options.distance !== 'function' || options.distance.length !== 2)) {\n      return callback(new Error('options.distance must be a function with two arguments'));\n    }\n    if (!_.isArray(vector)) {\n      return callback(new Error('Provide an array of data'));\n    }\n\n    this.options = options;\n    this.v = this.checkV(vector);\n    this.k = this.options.k;\n    this.distanceFunction = this.options.distance || euclidianDistance;\n    if (this.v.length < this.k) {\n      const errMessage = `The number of points must be greater than\n      the number k of clusters`;\n      return callback(new Error(errMessage));\n    }\n\n    this.initialize(); // initialize the group arrays\n\n    const self = this;\n    let moved = -1;\n\n    function iterate() {\n      if (moved === 0) {\n        return callback(null, self.output()); // converged if 0 centroid has moved\n      }\n      moved = 0;\n      for (let i = 0, max = self.groups.length; i < max; ++i) {\n        self.groups[i].defineCentroid(self); // define the new centroids\n        self.groups[i].distanceObjects(self); // distances from centroids to items\n      }\n      self.clustering(); // clustering by choosing the centroid the closest of each item\n      for (let i = 0, max = self.groups.length; i < max; ++i) {\n        // check how many centroids have moved in this iteration\n        if (self.groups[i].centroidMoved) {\n          moved++;\n        }\n      }\n      return process.nextTick(iterate);\n    }\n    return iterate();\n  }\n\n  checkV(v) {\n    let dim = 1;\n    if (_.isArray(v[0])) {\n      dim = v[0].length;\n    }\n    for (let i = 0, max = v.length; i < max; ++i) {\n      if (!_.isArray(v[i])) {\n        if (dim !== 1) {\n          throw new Error('All the elements must have the same dimension');\n        }\n        v[i] = Number(v[i]);\n        if (Number.isNaN(v[i])) {\n          throw new Error('All the elements must be float type');\n        }\n      } else {\n        if (v[i].length !== dim) {\n          throw new Error('All the elements must have the same dimension');\n        }\n        for (let j = 0, max2 = v[i].length; j < max2; ++j) {\n          v[i][j] = Number(v[i][j]);\n          if (Number.isNaN(v[i][j])) {\n            throw new Error('All the elements must be float type');\n          }\n        }\n      }\n    }\n    return v;\n  }\n\n  initialize() {\n    this.groups = [];\n    for (let i = 0, max = this.k; i < max; ++i) {\n      this.groups[i] = new Group(this);\n    }\n    this.indexes = []; // used to choose randomly the initial centroids\n    for (let i = 0, max = this.v.length; i < max; ++i) {\n      this.indexes[i] = i;\n    }\n    return this;\n  }\n\n  clustering() {\n    for (let j = 0, max = this.groups.length; j < max; ++j) {\n      this.groups[j].initCluster();\n    }\n    for (let i = 0, max = this.v.length; i < max; ++i) {\n      let min = this.groups[0].distances[i];\n      let indexGroup = 0;\n      for (let j = 1, max2 = this.groups.length; j < max2; ++j) {\n        if (this.groups[j].distances[i] < min) {\n          min = this.groups[j].distances[i];\n          indexGroup = j;\n        }\n      }\n      this.groups[indexGroup].cluster.push(this.v[i]);\n      this.groups[indexGroup].clusterInd.push(i);\n    }\n    return this;\n  }\n\n  output() {\n    const out = [];\n    for (let j = 0, max = this.groups.length; j < max; ++j) {\n      out[j] = _.pick(this.groups[j], 'centroid', 'cluster', 'clusterInd');\n    }\n    return out;\n  }\n}\n\nexports.clusterize = (vector, options, callback) => {\n  return new Clusterize(vector, options, callback);\n};\n\nexports._class = Clusterize;\n"]},"metadata":{},"sourceType":"script"}